// This file is generated by Umi automatically
// DO NOT CHANGE IT MANUALLY!
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/babel.ts
var babel_exports = {};
__export(babel_exports, {
  default: () => wrapKeepAlivePlugin
});
module.exports = __toCommonJS(babel_exports);
function addAliasImport(path, t, importName) {
  const programPath = path.findParent(
    (path2) => path2.isProgram()
  );
  const aliasName = importName || "createContext";
  const hasImport = programPath && programPath.node.body.find((node) => {
    if (t.isImportDeclaration(node)) {
      const specifiers = node.specifiers;
      return specifiers && t.isStringLiteral(node.source, {
        type: "StringLiteral",
        value: "react-activation"
      }) && specifiers.find((specifier) => {
        if (t.isImportSpecifier(specifier)) {
          const local = specifier.local;
          const imported = specifier.imported;
          return local && imported.type === "Identifier" && imported.name === "createContext" && local.type === "Identifier" && local.name === aliasName;
        }
        return false;
      });
    }
    return false;
  });
  if (!hasImport) {
    const importDefault = t.importSpecifier(
      t.identifier(aliasName),
      t.identifier("createContext")
    );
    const imports = t.importDeclaration(
      [importDefault],
      t.stringLiteral("react-activation")
    );
    programPath.node.body.splice(0, 0, imports);
  }
}
function wrapKeepAlivePlugin(babel) {
  let t = babel.types;
  return {
    visitor: {
      ImportDeclaration(path, state) {
        const programPath = path.findParent(
          (path2) => path2.isProgram()
        );
        let importCreateContextFromReact = false;
        let aliasName = void 0;
        if (programPath) {
          const nodeIndex = programPath.node.body.findIndex((node) => {
            if (t.isImportDeclaration(node)) {
              const specifiers = node.specifiers;
              if (specifiers && t.isStringLiteral(node.source, {
                type: "StringLiteral",
                value: "react"
              })) {
                const importIndex = specifiers.findIndex((specifier) => {
                  if (t.isImportSpecifier(specifier)) {
                    const local = specifier.local;
                    const imported = specifier.imported || local;
                    return local && imported.type === "Identifier" && imported.name === "createContext";
                  }
                  return false;
                });
                if (importIndex > -1) {
                  aliasName = specifiers[importIndex].local.name;
                  node.specifiers.splice(importIndex, 1);
                  return true;
                }
                return false;
              }
            }
            return false;
          });
          if (nodeIndex > -1) {
            importCreateContextFromReact = true;
            const node = programPath.node.body[nodeIndex];
            if (t.isImportDeclaration(node) && node.specifiers.length === 0) {
              programPath.node.body.splice(nodeIndex, 1);
            }
          }
        }
        if (importCreateContextFromReact) {
          addAliasImport(path, t, aliasName);
        }
        if (programPath) {
          programPath.node.body.forEach((node) => {
            if (t.isImportDeclaration(node)) {
              const specifiers = node.specifiers;
              if (specifiers && t.isStringLiteral(node.source, {
                type: "StringLiteral",
                value: "react"
              })) {
                specifiers.forEach((specifier) => {
                  const isDefaultImport = t.isImportDefaultSpecifier(specifier);
                  const isNameSpaceImport = t.isImportNamespaceSpecifier(specifier);
                  if (isDefaultImport || isNameSpaceImport) {
                    addAliasImport(path, t, void 0);
                    const globalName = specifier.local.name;
                    programPath.traverse({
                      MemberExpression(path2) {
                        const node2 = path2.node;
                        const object = node2.object;
                        const property = node2.property;
                        if (object && property && object.type === "Identifier" && object.name === globalName && property.type === "Identifier" && property.name === "createContext") {
                          const funcId = t.identifier("createContext");
                          path2.replaceWith(funcId);
                        }
                      }
                    });
                  }
                });
              }
            }
          });
        }
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
